
## Пример 1: использование await c корутиной
```py 
import asyncio
import time
# использование await с корутиной
async def coro(num,second):
    print(f'coro {num}, начало свое выполнение')
    await asyncio.sleep(second)
    print(f'coro {num} выполнена за {second} секунд(ы)')
    
    
async def main():
    # создание объектов корутин путем вызова корутинной функции
    coro1 = coro(1,2)
    coro2 = coro(2,1)
    # запуск и ожидание выполнения объектов корутин
    await coro1
    await coro2    
    
    start = time.time()
    asyncio.run(main())
    
    print(f'ПРОГРАММА ВЫПОЛНЕНА ЗА {time.time() - start:.3f}')

"""

coro 1, начало свое выполнение
coro 1 выполнена за 2 секунд(ы)
coro 2, начало свое выполнение
coro 2 выполнена за 1 секунд(ы)
ПРОГРАММА ВЫПОЛНЕНА ЗА 3.024
"""

```


сначала coro1, затем coro2, порядок выполнения следует порядку их вызова через await. Это связано с тем, что выполнение каждой корутины начинается только тогда, когда мы явно запускаем корутину через await coro.

## Использование await c объектом Task

```python
import asyncio
import time
async def coro(num,second):
    print(f'coro {num}, начало свое выполнение')
    await asyncio.sleep(second)
    print(f'coro {num} выполнена за {second} секунд(ы)')


async def main():
    # создание объектов корутин путем вызова корутинной функции
    task1 = asyncio.create_task(coro(1,2))
    task2 = asyncio.create_task(coro(2, 1))
    # запуск и ожидание выполнения объектов корутин
    await task1
    await task2


start = time.time()
asyncio.run(main())

print(f'ПРОГРАММА ВЫПОЛНЕНА ЗА {time.time() - start:.3f}')
"""
coro 1, начало свое выполнение
coro 2, начало свое выполнение
coro 2 выполнена за 1 секунд(ы)
coro 1 выполнена за 2 секунд(ы)
ПРОГРАММА ВЫПОЛНЕНА ЗА 2.009
"""
```

Задачи начинают выполняться в порядке создания, и их выполнение происходит асинхронно. Общее время выполнения немного превышает время выполнения самой "долгой" задачи. Это связано с тем, что задача при создании добавляется в цикл событий и начинает выполнение при переключении контекста. То есть обе созданные задачи начнут выполнение при первом await

### итог 
Первое -- это корутины, второе -- таски. В свою очередь таски начинают свое выполнение в порядке создания, корутины в порядке ожидания (await) результата.

# Ключевое слово await
#ключевое-слово-await
**Правила и особенности использования await.**

await - это ключевое слово, которое используется для переключения 
между awaitable объектами.Основная задача асинхронного программирования - 
конкурентное выполнение задач. Это возможно благодаря await. Когда интерпретатор Python встречает ключевое слово await, он приостанавливает в
ыполнение текущей функции и передает управление обратно в цикл событий. 


```python
import asyncio
# Ключевое слово await

async def my_coro(num):
    print(f'Начинаем выполнение корутины {num}')
    await asyncio.sleep(1)
    print(f'Закончили выполнение корутины {num}')

async  def main():
    task = [asyncio.create_task(my_coro(i)) for i in range(1,6)]
    await asyncio.gather(*task)


if __name__ == '__main__':
    asyncio.run(main())
"""
Начинаем выполнение корутины 1
Начинаем выполнение корутины 2
Начинаем выполнение корутины 3
Начинаем выполнение корутины 4
Начинаем выполнение корутины 5
Закончили выполнение корутины 1
Закончили выполнение корутины 2
Закончили выполнение корутины 3
Закончили выполнение корутины 4
Закончили выполнение корутины 5
"""
```

- await нельзя использовать с не awaitable объектами
- await нельзя использовать вне корутин. 
- await блокирует выполнение корутины.
```python
import asyncio
async def coro():
    print(f'Начинает выполнение')
    await asyncio.sleep(1)  # Тут блокируется корутина сoro() до завершения asyncio.sleep().
    print(f'Закончил')

async def main():
    await coro() # Тут блокируется main() до завершения my_coroutine().
    print('Выполнение корутины закончили')

if __name__ == '__main__':
    asyncio.run(main())
"""
Начинает выполнение
Закончил
Выполнение корутины закончили
"""
```
В данном примере выполнение корутины my_coroutine() блокируется на 1 секунду на строчкеawait asyncio.sleep(1). Блокировка текущей корутины закончится, когда asyncio.sleep(1) вернет результат. После этого корутина может продолжить выполнение.
Выполнение основной корутины main() также блокируется на строчкеawait my_coroutine(), а блокировка завершается когда выполнение ожидаемой корутины завершается.  

- await можно сохранять результат
```python
import asyncio
# await может возвращать результат

async def coro():
    await asyncio.sleep(1)
    return 'Задача завершена'

async def main():
    result = await coro() # сохраняем в переменную результат выполнения my_coroutine() 
    print(result)

if __name__ == '__main__':
    asyncio.run(main())
"""
Задача завершена
"""
```

`await asyncio.gather(*tasks)` дожидается выполнения всех задач возвращает список результатов всех задач.

```python
import asyncio
async def coro(num):
    print('Начало',num)
    await asyncio.sleep(1)
    return f'Задача завершена {num}'

async def main():
    task = [asyncio.create_task(coro(i) )for i in range(1,6)]
    result = await asyncio.gather(*task)
    print(result)
if __name__ == '__main__':
    asyncio.run(main())

"""
Начало 1
Начало 2
Начало 3
Начало 4
Начало 5
['Задача завершена 1', 'Задача завершена 2', 'Задача завершена 3', 'Задача завершена 4', 'Задача завершена 5']
"""
```


